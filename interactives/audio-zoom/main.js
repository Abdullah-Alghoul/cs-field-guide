(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
"use strict";
var SCALE, async, split, toAudioBuffer, wait;

async = require('es6-simple-async');

toAudioBuffer = function(arrayBuffer) {

  /* This converts an ArrayBuffer into an AudioBuffer returning a Promise
      containing the AudioBuffer
   */
  var audioCtx;
  audioCtx = new OfflineAudioContext(2, 44100 * 1, 44100);
  return audioCtx.decodeAudioData(arrayBuffer);
};

SCALE = 30;

split = function(arr, chunks) {
  var change, currentLocation, nextLocation, result;
  if (chunks == null) {
    chunks = 2;
  }

  /* Splits an array into given number of chunks, the final chunk may
      be smaller than the rest, if chunks > array.length then we'll throw
      an error
   */
  if (chunks > arr.length) {
    throw new Error("Can't split arr with length " + arr.length + " into " + chunks + " chunks");
  }
  result = [];
  currentLocation = 0;
  change = arr.length / chunks;
  while (currentLocation < arr.length) {
    nextLocation = currentLocation + change;
    result.push(arr.slice(Math.round(currentLocation), Math.round(nextLocation)));
    currentLocation = nextLocation;
  }
  return result;
};

wait = function(time) {
  return new Promise(function(resolve) {
    return setTimeout(resolve, time);
  });
};

async.main(function*() {
  var $audio, $image, $status, arrBuff, audioData, audioPart, channelData, idx, lines, max, maxHeight, min, res, svgLine;
  $audio = document.querySelector('#audio3');
  $status = document.querySelector('#status');
  $image = document.querySelector('#img');
  $status.innerHTML = 'fetching...';
  res = (yield fetch($audio.getAttribute('src')));
  arrBuff = (yield res.arrayBuffer());
  $status.innerHTML = 'converting...';
  audioData = (yield toAudioBuffer(arrBuff));
  $status.innerHTML = 'scanning points...';
  channelData = audioData.getChannelData(0);
  maxHeight = channelData.reduce(function(acc, i) {
    return Math.max(acc, Math.abs(i));
  });
  $status.innerHTML = 'creating lines';
  window.audioParts = (yield split(channelData, 1000));
  lines = (yield* (function*() {
    var j, len, results;
    results = [];
    for (idx = j = 0, len = audioParts.length; j < len; idx = ++j) {
      audioPart = audioParts[idx];
      max = audioPart.reduce(function(acc, i) {
        return Math.max(acc, i);
      });
      min = audioPart.reduce(function(acc, i) {
        return Math.min(acc, i);
      });
      svgLine = document.createElementNS($image.namespaceURI, "line");
      svgLine.setAttributeNS(null, "class", "wave-line");
      svgLine.setAttributeNS(null, "x1", idx);
      svgLine.setAttributeNS(null, "x2", idx);
      svgLine.setAttributeNS(null, "y1", 500 * min / maxHeight + 500);
      svgLine.setAttributeNS(null, "y2", 500 * max / maxHeight + 500);
      $image.appendChild(svgLine);
      results.push((yield void 0));
    }
    return results;
  })());
  svgLine = document.createElementNS($image.namespaceURI, "line");
  svgLine.setAttributeNS(null, "style", "stroke:red;stroke-width:1");
  svgLine.setAttributeNS(null, "x1", 0);
  svgLine.setAttributeNS(null, "x2", 1000);
  svgLine.setAttributeNS(null, "y1", 500);
  svgLine.setAttributeNS(null, "y2", 500);
  $image.appendChild(svgLine);
  $status.innerHTML = 'done and done';
  return 2;
});


},{"es6-simple-async":2}],2:[function(require,module,exports){
// Generated by CoffeeScript 1.10.0

/* Author James "The Jamesernator" Browning
    2016
 */

(function() {
  "use strict";
  var GeneratorFunction, async,
    slice = [].slice;

  GeneratorFunction = Object.getPrototypeOf(function*() {
    return;
  }).constructor;

  async = function(genFunc) {

    /* async converts a GeneratorFunction into a ES7 async function */
    var spawn;
    if (!(genFunc instanceof GeneratorFunction)) {
      throw new Error("Passed non-generator to async");
    }
    return spawn = function() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return new Promise((function(_this) {
        return function(resolve, reject) {
          var gen, step;
          gen = genFunc.apply(_this, args);
          step = function(nextFunc) {
            var err, error, next;
            try {
              next = nextFunc();
            } catch (error) {
              err = error;
              reject(err);
              return;
            }
            if (next.done) {
              resolve(next.value);
              return;
            }
            return Promise.resolve(next.value).then(function(val) {
              return step(function() {
                return gen.next(val);
              });
            }, function(err) {
              return step(function() {
                return gen["throw"](err);
              });
            });
          };
          return step(function() {
            return gen.next(void 0);
          });
        };
      })(this));
    };
  };

  async.run = function(func, errCallback) {
    if (errCallback == null) {
      errCallback = console.log;
    }

    /* This tries running the async function given and if it
        fails it calls the errCallback with the error given
        by the async function
     */
    return async(function*() {
      var err, error;
      try {
        return (yield async(func)());
      } catch (error) {
        err = error;
        return errCallback(err);
      }
    })();
  };

  async.main = function(func) {

    /* Although async.run has errCallback as console.log we'll just print
        the stack
     */
    return async.run(func, function(err) {
      return console.log(err.stack);
    });
  };

  async.from = function(iterable) {

    /* Creates a async function from an existing iterable */
    var genFunc;
    genFunc = function*() {
      return (yield* iterable);
    };
    return async(genFunc);
  };

  async["do"] = async.run;

  Object.defineProperty(async, "name", {
    value: "async"
  });

  if (typeof module !== "undefined" && module !== null) {
    module.exports = async;
  } else {
    window.async = async;
  }

}).call(this);

},{}]},{},[1]);
